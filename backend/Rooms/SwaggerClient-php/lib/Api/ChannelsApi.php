<?php
/**
 * ChannelsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Rooms
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.67
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ChannelsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ChannelsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getApiV1ChannelsAnonymousread
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2003
     */
    public function getApiV1ChannelsAnonymousread($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        list($response) = $this->getApiV1ChannelsAnonymousreadWithHttpInfo($room_id, $room_name, $offset, $count, $sort, $query, $fields);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadWithHttpInfo
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsAnonymousreadWithHttpInfo($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003';
        $request = $this->getApiV1ChannelsAnonymousreadRequest($room_id, $room_name, $offset, $count, $sort, $query, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadAsync
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsAnonymousreadAsync($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        return $this->getApiV1ChannelsAnonymousreadAsyncWithHttpInfo($room_id, $room_name, $offset, $count, $sort, $query, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsAnonymousreadAsyncWithHttpInfo
     *
     * Read Channel Messages Anonymously
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsAnonymousreadAsyncWithHttpInfo($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003';
        $request = $this->getApiV1ChannelsAnonymousreadRequest($room_id, $room_name, $offset, $count, $sort, $query, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsAnonymousread'
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsAnonymousreadRequest($room_id = null, $room_name = null, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {

        $resourcePath = '/api/v1/channels.anonymousread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsCounters
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2004
     */
    public function getApiV1ChannelsCounters($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null)
    {
        list($response) = $this->getApiV1ChannelsCountersWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $user_id);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsCountersWithHttpInfo
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsCountersWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004';
        $request = $this->getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsCountersAsync
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsCountersAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null)
    {
        return $this->getApiV1ChannelsCountersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsCountersAsyncWithHttpInfo
     *
     * Get Channel Counters
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsCountersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004';
        $request = $this->getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsCounters'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $user_id The user ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsCountersRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $user_id = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsCounters'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsCounters'
            );
        }

        $resourcePath = '/api/v1/channels.counters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsFiles
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2005
     */
    public function getApiV1ChannelsFiles($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null)
    {
        list($response) = $this->getApiV1ChannelsFilesWithHttpInfo($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsFilesWithHttpInfo
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsFilesWithHttpInfo($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005';
        $request = $this->getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsFilesAsync
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsFilesAsync($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null)
    {
        return $this->getApiV1ChannelsFilesAsyncWithHttpInfo($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsFilesAsyncWithHttpInfo
     *
     * Get Channel Files
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsFilesAsyncWithHttpInfo($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005';
        $request = $this->getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id, $room_name, $fields, $query, $sort, $count, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsFiles'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsFilesRequest($x_user_id, $x_auth_token, $room_id = null, $room_name = null, $fields = null, $query = null, $sort = null, $count = null, $offset = null)
    {
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsFiles'
            );
        }
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsFiles'
            );
        }

        $resourcePath = '/api/v1/channels.files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannel
     *
     * Get User Mentions in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20023
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannel($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null)
    {
        list($response) = $this->getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo
     *
     * Get User Mentions in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20023';
        $request = $this->getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelAsync
     *
     * Get User Mentions in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelAsync($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null)
    {
        return $this->getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo
     *
     * Get User Mentions in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetAllUserMentionsByChannelAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20023';
        $request = $this->getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset, $count, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsGetAllUserMentionsByChannel'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsGetAllUserMentionsByChannelRequest($x_auth_token, $x_user_id, $room_id, $offset = null, $count = null, $sort = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }
        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsGetAllUserMentionsByChannel'
            );
        }

        $resourcePath = '/api/v1/channels.getAllUserMentionsByChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsGetIntegrations
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  int $count The number of items to return. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20024
     */
    public function getApiV1ChannelsGetIntegrations($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null)
    {
        list($response) = $this->getApiV1ChannelsGetIntegrationsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsWithHttpInfo
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  int $count The number of items to return. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20024, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsGetIntegrationsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20024';
        $request = $this->getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20024',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsAsync
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  int $count The number of items to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetIntegrationsAsync($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null)
    {
        return $this->getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo
     *
     * Get Channel Integrations
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  int $count The number of items to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsGetIntegrationsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20024';
        $request = $this->getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset, $sort, $fields, $query, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsGetIntegrations'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  int $count The number of items to return. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsGetIntegrationsRequest($x_auth_token, $x_user_id, $room_id, $offset = null, $sort = null, $fields = null, $query = null, $count = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsGetIntegrations'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsGetIntegrations'
            );
        }
        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsGetIntegrations'
            );
        }

        $resourcePath = '/api/v1/channels.getIntegrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsHistory
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2005
     */
    public function getApiV1ChannelsHistory($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null)
    {
        list($response) = $this->getApiV1ChannelsHistoryWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsHistoryWithHttpInfo
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsHistoryWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005';
        $request = $this->getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsHistoryAsync
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsHistoryAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null)
    {
        return $this->getApiV1ChannelsHistoryAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsHistoryAsyncWithHttpInfo
     *
     * Get Channel History
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsHistoryAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005';
        $request = $this->getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id, $room_name, $sort, $count, $offset, $latest, $oldest, $inclusive, $show_thread_messages, $unreads);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsHistory'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $latest The end of time range of messages to retrieve. The default value is the current date and time. (optional)
     * @param  string $oldest The start of the time range of messages to retrieve (optional)
     * @param  bool $inclusive Whether messages which land on the latest and oldest dates should be included. The default value is false. (optional)
     * @param  bool $show_thread_messages Whether thread messages should be included in the response (optional)
     * @param  bool $unreads Whether the number of unread messages should be included. The default value is false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsHistoryRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $sort = null, $count = null, $offset = null, $latest = null, $oldest = null, $inclusive = null, $show_thread_messages = null, $unreads = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsHistory'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsHistory'
            );
        }

        $resourcePath = '/api/v1/channels.history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($latest !== null) {
            $queryParams['latest'] = ObjectSerializer::toQueryValue($latest, null);
        }
        // query params
        if ($oldest !== null) {
            $queryParams['oldest'] = ObjectSerializer::toQueryValue($oldest, null);
        }
        // query params
        if ($inclusive !== null) {
            $queryParams['inclusive'] = ObjectSerializer::toQueryValue($inclusive, null);
        }
        // query params
        if ($show_thread_messages !== null) {
            $queryParams['showThreadMessages'] = ObjectSerializer::toQueryValue($show_thread_messages, null);
        }
        // query params
        if ($unreads !== null) {
            $queryParams['unreads'] = ObjectSerializer::toQueryValue($unreads, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function getApiV1ChannelsInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        list($response) = $this->getApiV1ChannelsInfoWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsInfoWithHttpInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsInfoWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id, $room_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsInfoAsync
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsInfoAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        return $this->getApiV1ChannelsInfoAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsInfoAsyncWithHttpInfo
     *
     * Get Channel Information
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsInfoAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id, $room_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsInfo'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsInfoRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsInfo'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsInfo'
            );
        }

        $resourcePath = '/api/v1/channels.info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsList
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2009
     */
    public function getApiV1ChannelsList($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        list($response) = $this->getApiV1ChannelsListWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsListWithHttpInfo
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2009, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsListWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2009';
        $request = $this->getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2009',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsListAsync
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListAsync($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        return $this->getApiV1ChannelsListAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsListAsyncWithHttpInfo
     *
     * Get Channel List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2009';
        $request = $this->getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsList'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsListRequest($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsList'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsList'
            );
        }

        $resourcePath = '/api/v1/channels.list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsListJoined
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2008
     */
    public function getApiV1ChannelsListJoined($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        list($response) = $this->getApiV1ChannelsListJoinedWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsListJoinedWithHttpInfo
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsListJoinedWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008';
        $request = $this->getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsListJoinedAsync
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListJoinedAsync($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        return $this->getApiV1ChannelsListJoinedAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsListJoinedAsyncWithHttpInfo
     *
     * Get List of Joined Channels
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsListJoinedAsyncWithHttpInfo($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008';
        $request = $this->getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset, $count, $sort, $query, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsListJoined'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param   $query This parameter allows you to use MongoDB query operators to search for specific data. For example, to query users with a name that contains the letter \&quot;g\&quot;: &#x60;query&#x3D;{ \&quot;name\&quot;: { \&quot;$regex\&quot;: \&quot;g\&quot; } }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     * @param  string $fields This parameter accepts a JSON object with properties that have a value of 1 or 0 to include or exclude them in the response. For example, to only retrieve the usernames of users: &#x60;fields&#x3D;{ \&quot;username\&quot;: 1 }&#x60;. Refer to the [official documentation](https://developer.rocket.chat/apidocs/query-parameters#query-and-fields) to learn more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsListJoinedRequest($x_auth_token, $x_user_id, $offset = null, $count = null, $sort = null, $query = null, $fields = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsListJoined'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsListJoined'
            );
        }

        $resourcePath = '/api/v1/channels.list.joined';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsMembers
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#x27;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20010
     */
    public function getApiV1ChannelsMembers($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null)
    {
        list($response) = $this->getApiV1ChannelsMembersWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsMembersWithHttpInfo
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#x27;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20010, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsMembersWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010';
        $request = $this->getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20010',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsMembersAsync
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#x27;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMembersAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null)
    {
        return $this->getApiV1ChannelsMembersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsMembersAsyncWithHttpInfo
     *
     * Get Members of a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#x27;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMembersAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010';
        $request = $this->getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id, $room_name, $status, $filter, $sort, $count, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsMembers'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     * @param  string[] $status The user&#x27;s status (search filter). (optional)
     * @param  string $filter Extra search filters to be applied to the fields defined in the &#x60;Accounts_SearchFields&#x60;setting. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $count The number of items to return. (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsMembersRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null, $status = null, $filter = null, $sort = null, $count = null, $offset = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsMembers'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsMembers'
            );
        }

        $resourcePath = '/api/v1/channels.members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // query params
        if (is_array($status)) {
            $status = ObjectSerializer::serializeCollection($status, 'multi', true);
        }
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsMessages
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $mention_ids Filter the messages where a user has been mentioned by the userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  string $starred_ids Filter the messages a user have starred by userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  bool $pinned Filter pinned messages. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20011
     */
    public function getApiV1ChannelsMessages($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $offset = null, $mention_ids = null, $starred_ids = null, $pinned = null)
    {
        list($response) = $this->getApiV1ChannelsMessagesWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count, $sort, $offset, $mention_ids, $starred_ids, $pinned);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsMessagesWithHttpInfo
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $mention_ids Filter the messages where a user has been mentioned by the userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  string $starred_ids Filter the messages a user have starred by userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  bool $pinned Filter pinned messages. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20011, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsMessagesWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $offset = null, $mention_ids = null, $starred_ids = null, $pinned = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011';
        $request = $this->getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count, $sort, $offset, $mention_ids, $starred_ids, $pinned);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsMessagesAsync
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $mention_ids Filter the messages where a user has been mentioned by the userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  string $starred_ids Filter the messages a user have starred by userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  bool $pinned Filter pinned messages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMessagesAsync($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $offset = null, $mention_ids = null, $starred_ids = null, $pinned = null)
    {
        return $this->getApiV1ChannelsMessagesAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count, $sort, $offset, $mention_ids, $starred_ids, $pinned)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsMessagesAsyncWithHttpInfo
     *
     * Get Channel Messages
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $mention_ids Filter the messages where a user has been mentioned by the userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  string $starred_ids Filter the messages a user have starred by userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  bool $pinned Filter pinned messages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsMessagesAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $offset = null, $mention_ids = null, $starred_ids = null, $pinned = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011';
        $request = $this->getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count, $sort, $offset, $mention_ids, $starred_ids, $pinned);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsMessages'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room id. (required)
     * @param  int $count The number of items to return. (optional)
     * @param   $sort List of fields to order by, and in which direction. This is a JSON object, with properties listed in desired order, with values of 1 for ascending, or -1 for descending. For example, {\&quot;value\&quot;: -1, \&quot;_id\&quot;: 1} (optional)
     * @param  int $offset Number of items to \&quot;skip\&quot; in the query, i.e. requests return count items, skipping the first offset items. (optional)
     * @param  string $mention_ids Filter the messages where a user has been mentioned by the userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  string $starred_ids Filter the messages a user have starred by userId. For a set of userIds, use an array (&#x60;[\&quot;838ndhd79w\&quot;, \&quot;dud0wu900\&quot;]&#x60;). (optional)
     * @param  bool $pinned Filter pinned messages. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsMessagesRequest($x_auth_token, $x_user_id, $room_id, $count = null, $sort = null, $offset = null, $mention_ids = null, $starred_ids = null, $pinned = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsMessages'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsMessages'
            );
        }
        // verify the required parameter 'room_id' is set
        if ($room_id === null || (is_array($room_id) && count($room_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_id when calling getApiV1ChannelsMessages'
            );
        }

        $resourcePath = '/api/v1/channels.messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, null);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }
        // query params
        if ($mention_ids !== null) {
            $queryParams['mentionIds'] = ObjectSerializer::toQueryValue($mention_ids, null);
        }
        // query params
        if ($starred_ids !== null) {
            $queryParams['starredIds'] = ObjectSerializer::toQueryValue($starred_ids, null);
        }
        // query params
        if ($pinned !== null) {
            $queryParams['pinned'] = ObjectSerializer::toQueryValue($pinned, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsModerators
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20012
     */
    public function getApiV1ChannelsModerators($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        list($response) = $this->getApiV1ChannelsModeratorsWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsModeratorsWithHttpInfo
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsModeratorsWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012';
        $request = $this->getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id, $room_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsModeratorsAsync
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsModeratorsAsync($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        return $this->getApiV1ChannelsModeratorsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id, $room_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsModeratorsAsyncWithHttpInfo
     *
     * Get Channel Moderators
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsModeratorsAsyncWithHttpInfo($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012';
        $request = $this->getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id, $room_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsModerators'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsModeratorsRequest($x_auth_token, $x_user_id, $room_id = null, $room_name = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsModerators'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsModerators'
            );
        }

        $resourcePath = '/api/v1/channels.moderators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsOnline
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $_id The channel&#x27;s id. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20013
     */
    public function getApiV1ChannelsOnline($x_auth_token, $x_user_id, $_id)
    {
        list($response) = $this->getApiV1ChannelsOnlineWithHttpInfo($x_auth_token, $x_user_id, $_id);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsOnlineWithHttpInfo
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $_id The channel&#x27;s id. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsOnlineWithHttpInfo($x_auth_token, $x_user_id, $_id)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20013';
        $request = $this->getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsOnlineAsync
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $_id The channel&#x27;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsOnlineAsync($x_auth_token, $x_user_id, $_id)
    {
        return $this->getApiV1ChannelsOnlineAsyncWithHttpInfo($x_auth_token, $x_user_id, $_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsOnlineAsyncWithHttpInfo
     *
     * List Online Users in a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $_id The channel&#x27;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsOnlineAsyncWithHttpInfo($x_auth_token, $x_user_id, $_id)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20013';
        $request = $this->getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsOnline'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $_id The channel&#x27;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsOnlineRequest($x_auth_token, $x_user_id, $_id)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling getApiV1ChannelsOnline'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling getApiV1ChannelsOnline'
            );
        }
        // verify the required parameter '_id' is set
        if ($_id === null || (is_array($_id) && count($_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $_id when calling getApiV1ChannelsOnline'
            );
        }

        $resourcePath = '/api/v1/channels.online';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($_id !== null) {
            $queryParams['_id'] = ObjectSerializer::toQueryValue($_id, null);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApiV1ChannelsRoles
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20014
     */
    public function getApiV1ChannelsRoles($room_id = null, $room_name = null)
    {
        list($response) = $this->getApiV1ChannelsRolesWithHttpInfo($room_id, $room_name);
        return $response;
    }

    /**
     * Operation getApiV1ChannelsRolesWithHttpInfo
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApiV1ChannelsRolesWithHttpInfo($room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014';
        $request = $this->getApiV1ChannelsRolesRequest($room_id, $room_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApiV1ChannelsRolesAsync
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsRolesAsync($room_id = null, $room_name = null)
    {
        return $this->getApiV1ChannelsRolesAsyncWithHttpInfo($room_id, $room_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApiV1ChannelsRolesAsyncWithHttpInfo
     *
     * Get Channel Roles
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApiV1ChannelsRolesAsyncWithHttpInfo($room_id = null, $room_name = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014';
        $request = $this->getApiV1ChannelsRolesRequest($room_id, $room_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApiV1ChannelsRoles'
     *
     * @param  string $room_id The room ID. It is required if the &#x60;roomName&#x60; is not provided. (optional)
     * @param  string $room_name The room name.  It is required if the &#x60;roomId&#x60; is not provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApiV1ChannelsRolesRequest($room_id = null, $room_name = null)
    {

        $resourcePath = '/api/v1/channels.roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($room_id !== null) {
            $queryParams['roomId'] = ObjectSerializer::toQueryValue($room_id, null);
        }
        // query params
        if ($room_name !== null) {
            $queryParams['roomName'] = ObjectSerializer::toQueryValue($room_name, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation posApiV1ChannelsRename
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRenameBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2007
     */
    public function posApiV1ChannelsRename($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->posApiV1ChannelsRenameWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation posApiV1ChannelsRenameWithHttpInfo
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRenameBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function posApiV1ChannelsRenameWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007';
        $request = $this->posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse4003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation posApiV1ChannelsRenameAsync
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRenameBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function posApiV1ChannelsRenameAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->posApiV1ChannelsRenameAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation posApiV1ChannelsRenameAsyncWithHttpInfo
     *
     * Rename a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRenameBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function posApiV1ChannelsRenameAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007';
        $request = $this->posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'posApiV1ChannelsRename'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRenameBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function posApiV1ChannelsRenameRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling posApiV1ChannelsRename'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling posApiV1ChannelsRename'
            );
        }

        $resourcePath = '/api/v1/channels.rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddAll
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddAllBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function postApiV1ChannelsAddAll($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsAddAllWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddAllWithHttpInfo
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddAllBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddAllWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddAllAsync
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddAllBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddAllAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsAddAllAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddAllAsyncWithHttpInfo
     *
     * Add all Users to a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddAllBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddAllAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddAll'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddAllBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsAddAllRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddAll'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddAll'
            );
        }

        $resourcePath = '/api/v1/channels.addAll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddLeader
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddLeaderBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsAddLeader($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsAddLeaderWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddLeaderWithHttpInfo
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddLeaderBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddLeaderWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddLeaderAsync
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddLeaderAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsAddLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddLeaderAsyncWithHttpInfo
     *
     * Add Channel Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddLeader'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsAddLeaderRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddLeader'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddLeader'
            );
        }

        $resourcePath = '/api/v1/channels.addLeader';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddModerator
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddModeratorBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsAddModerator($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsAddModeratorWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddModeratorWithHttpInfo
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddModeratorBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddModeratorWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddModeratorAsync
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddModeratorAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsAddModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddModeratorAsyncWithHttpInfo
     *
     * Add Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddModerator'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsAddModeratorRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddModerator'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddModerator'
            );
        }

        $resourcePath = '/api/v1/channels.addModerator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsAddOwner
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddOwnerBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsAddOwner($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsAddOwnerWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsAddOwnerWithHttpInfo
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddOwnerBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsAddOwnerWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsAddOwnerAsync
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddOwnerAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsAddOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsAddOwnerAsyncWithHttpInfo
     *
     * Add Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsAddOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsAddOwner'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsAddOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsAddOwnerRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsAddOwner'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsAddOwner'
            );
        }

        $resourcePath = '/api/v1/channels.addOwner';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsArchive
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsArchiveBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsArchive($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsArchiveWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsArchiveWithHttpInfo
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsArchiveBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsArchiveWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsArchiveAsync
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsArchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsArchiveAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsArchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsArchiveAsyncWithHttpInfo
     *
     * Archive Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsArchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsArchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsArchive'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsArchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsArchiveRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsArchive'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsArchive'
            );
        }

        $resourcePath = '/api/v1/channels.archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsClose
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCloseBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsClose($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsCloseWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsCloseWithHttpInfo
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCloseBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsCloseWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse4002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsCloseAsync
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCloseBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCloseAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsCloseAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsCloseAsyncWithHttpInfo
     *
     * Close Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCloseBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCloseAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsClose'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCloseBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsCloseRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsClose'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsClose'
            );
        }

        $resourcePath = '/api/v1/channels.close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsConvertToTeam
     *
     * Convert Channel to Team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsConvertToTeamBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20025
     */
    public function postApiV1ChannelsConvertToTeam($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsConvertToTeamWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamWithHttpInfo
     *
     * Convert Channel to Team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsConvertToTeamBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsConvertToTeamWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20025';
        $request = $this->postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamAsync
     *
     * Convert Channel to Team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsConvertToTeamBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsConvertToTeamAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsConvertToTeamAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsConvertToTeamAsyncWithHttpInfo
     *
     * Convert Channel to Team
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsConvertToTeamBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsConvertToTeamAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20025';
        $request = $this->postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsConvertToTeam'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsConvertToTeamBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsConvertToTeamRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsConvertToTeam'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsConvertToTeam'
            );
        }

        $resourcePath = '/api/v1/channels.convertToTeam';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsCreate
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCreateBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse200
     */
    public function postApiV1ChannelsCreate($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsCreateWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsCreateWithHttpInfo
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCreateBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsCreateWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsCreateAsync
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCreateBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCreateAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsCreateAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsCreateAsyncWithHttpInfo
     *
     * Create Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCreateBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsCreateAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsCreate'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsCreateBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsCreateRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsCreate'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsCreate'
            );
        }

        $resourcePath = '/api/v1/channels.create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsDelete
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsDeleteBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsDelete($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsDeleteWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsDeleteWithHttpInfo
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsDeleteBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsDeleteWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsDeleteAsync
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsDeleteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsDeleteAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsDeleteAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsDeleteAsyncWithHttpInfo
     *
     * Delete Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsDeleteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsDeleteAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsDelete'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsDeleteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsDeleteRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsDelete'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsDelete'
            );
        }

        $resourcePath = '/api/v1/channels.delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsInvite
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsInviteBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2006
     */
    public function postApiV1ChannelsInvite($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsInviteWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsInviteWithHttpInfo
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsInviteBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsInviteWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2006';
        $request = $this->postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsInviteAsync
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsInviteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsInviteAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsInviteAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsInviteAsyncWithHttpInfo
     *
     * Add Users to Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsInviteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsInviteAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2006';
        $request = $this->postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsInvite'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsInviteBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsInviteRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsInvite'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsInvite'
            );
        }

        $resourcePath = '/api/v1/channels.invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsJoin
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsJoinBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function postApiV1ChannelsJoin($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsJoinWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsJoinWithHttpInfo
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsJoinBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsJoinWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsJoinAsync
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsJoinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsJoinAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsJoinAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsJoinAsyncWithHttpInfo
     *
     * Join a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsJoinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsJoinAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsJoin'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsJoinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsJoinRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsJoin'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsJoin'
            );
        }

        $resourcePath = '/api/v1/channels.join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsKick
     *
     * Remove User from Channel
     *
     * @param  \Swagger\Client\Model\V1ChannelsKickBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function postApiV1ChannelsKick($body = null)
    {
        list($response) = $this->postApiV1ChannelsKickWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsKickWithHttpInfo
     *
     * Remove User from Channel
     *
     * @param  \Swagger\Client\Model\V1ChannelsKickBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsKickWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsKickRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsKickAsync
     *
     * Remove User from Channel
     *
     * @param  \Swagger\Client\Model\V1ChannelsKickBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsKickAsync($body = null)
    {
        return $this->postApiV1ChannelsKickAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsKickAsyncWithHttpInfo
     *
     * Remove User from Channel
     *
     * @param  \Swagger\Client\Model\V1ChannelsKickBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsKickAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->postApiV1ChannelsKickRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsKick'
     *
     * @param  \Swagger\Client\Model\V1ChannelsKickBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsKickRequest($body = null)
    {

        $resourcePath = '/api/v1/channels.kick';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsLeave
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsLeaveBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2007
     */
    public function postApiV1ChannelsLeave($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsLeaveWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsLeaveWithHttpInfo
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsLeaveBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsLeaveWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007';
        $request = $this->postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsLeaveAsync
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsLeaveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsLeaveAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsLeaveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsLeaveAsyncWithHttpInfo
     *
     * Leave  Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsLeaveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsLeaveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007';
        $request = $this->postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsLeave'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsLeaveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsLeaveRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsLeave'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsLeave'
            );
        }

        $resourcePath = '/api/v1/channels.leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsOpen
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsOpenBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsOpen($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsOpenWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsOpenWithHttpInfo
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsOpenBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsOpenWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsOpenAsync
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsOpenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsOpenAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsOpenAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsOpenAsyncWithHttpInfo
     *
     * Add Channel to User List
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsOpenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsOpenAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsOpen'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsOpenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsOpenRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsOpen'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsOpen'
            );
        }

        $resourcePath = '/api/v1/channels.open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveLeader
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveLeaderBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsRemoveLeader($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsRemoveLeaderWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderWithHttpInfo
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveLeaderBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveLeaderWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderAsync
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveLeaderAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo
     *
     * Remove Channel  Leader
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveLeaderAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveLeader'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveLeaderBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsRemoveLeaderRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveLeader'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveLeader'
            );
        }

        $resourcePath = '/api/v1/channels.removeLeader';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveModerator
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveModeratorBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsRemoveModerator($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsRemoveModeratorWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorWithHttpInfo
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveModeratorBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveModeratorWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorAsync
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveModeratorAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo
     *
     * Remove Channel Moderator
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveModeratorAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveModerator'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveModeratorBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsRemoveModeratorRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveModerator'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveModerator'
            );
        }

        $resourcePath = '/api/v1/channels.removeModerator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsRemoveOwner
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveOwnerBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsRemoveOwner($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsRemoveOwnerWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerWithHttpInfo
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveOwnerBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsRemoveOwnerWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerAsync
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveOwnerAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo
     *
     * Remove Channel Owner
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsRemoveOwnerAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsRemoveOwner'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsRemoveOwnerBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsRemoveOwnerRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsRemoveOwner'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsRemoveOwner'
            );
        }

        $resourcePath = '/api/v1/channels.removeOwner';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncement
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetAnnouncementBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20015
     */
    public function postApiV1ChannelsSetAnnouncement($x_user_id, $x_auth_token, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetAnnouncementWithHttpInfo($x_user_id, $x_auth_token, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementWithHttpInfo
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetAnnouncementBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetAnnouncementWithHttpInfo($x_user_id, $x_auth_token, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015';
        $request = $this->postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementAsync
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetAnnouncementBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetAnnouncementAsync($x_user_id, $x_auth_token, $body = null)
    {
        return $this->postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo($x_user_id, $x_auth_token, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo
     *
     * Set Channel Announcement
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetAnnouncementBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetAnnouncementAsyncWithHttpInfo($x_user_id, $x_auth_token, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015';
        $request = $this->postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetAnnouncement'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetAnnouncementBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetAnnouncementRequest($x_user_id, $x_auth_token, $body = null)
    {
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetAnnouncement'
            );
        }
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetAnnouncement'
            );
        }

        $resourcePath = '/api/v1/channels.setAnnouncement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetCustomFields
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetCustomFieldsBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20016
     */
    public function postApiV1ChannelsSetCustomFields($x_user_id, $x_auth_token, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetCustomFieldsWithHttpInfo($x_user_id, $x_auth_token, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsWithHttpInfo
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetCustomFieldsBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetCustomFieldsWithHttpInfo($x_user_id, $x_auth_token, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20016';
        $request = $this->postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsAsync
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetCustomFieldsBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetCustomFieldsAsync($x_user_id, $x_auth_token, $body = null)
    {
        return $this->postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo($x_user_id, $x_auth_token, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo
     *
     * Set Channel Custom Fields
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetCustomFieldsBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetCustomFieldsAsyncWithHttpInfo($x_user_id, $x_auth_token, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20016';
        $request = $this->postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetCustomFields'
     *
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetCustomFieldsBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetCustomFieldsRequest($x_user_id, $x_auth_token, $body = null)
    {
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetCustomFields'
            );
        }
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetCustomFields'
            );
        }

        $resourcePath = '/api/v1/channels.setCustomFields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }
        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetDefault
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDefaultBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20017
     */
    public function postApiV1ChannelsSetDefault($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetDefaultWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetDefaultWithHttpInfo
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDefaultBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetDefaultWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20017';
        $request = $this->postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetDefaultAsync
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDefaultBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDefaultAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetDefaultAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetDefaultAsyncWithHttpInfo
     *
     * Set Default Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDefaultBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDefaultAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20017';
        $request = $this->postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetDefault'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDefaultBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetDefaultRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetDefault'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetDefault'
            );
        }

        $resourcePath = '/api/v1/channels.setDefault';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetDescription
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDescriptionBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20018
     */
    public function postApiV1ChannelsSetDescription($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetDescriptionWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionWithHttpInfo
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDescriptionBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetDescriptionWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20018';
        $request = $this->postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionAsync
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDescriptionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDescriptionAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetDescriptionAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetDescriptionAsyncWithHttpInfo
     *
     * Set Channel Description
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDescriptionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetDescriptionAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20018';
        $request = $this->postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetDescription'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetDescriptionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetDescriptionRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetDescription'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetDescription'
            );
        }

        $resourcePath = '/api/v1/channels.setDescription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetJoinCode
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetJoinCodeBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20019
     */
    public function postApiV1ChannelsSetJoinCode($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetJoinCodeWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeWithHttpInfo
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetJoinCodeBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetJoinCodeWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20019';
        $request = $this->postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeAsync
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetJoinCodeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetJoinCodeAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo
     *
     * Set Channel Join Code
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetJoinCodeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetJoinCodeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20019';
        $request = $this->postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetJoinCode'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetJoinCodeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetJoinCodeRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetJoinCode'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetJoinCode'
            );
        }

        $resourcePath = '/api/v1/channels.setJoinCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetPurpose
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetPurposeBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20020
     */
    public function postApiV1ChannelsSetPurpose($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetPurposeWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetPurposeWithHttpInfo
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetPurposeBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20020, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetPurposeWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020';
        $request = $this->postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20020',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetPurposeAsync
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetPurposeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetPurposeAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetPurposeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetPurposeAsyncWithHttpInfo
     *
     * Set Channel Purpose
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetPurposeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetPurposeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020';
        $request = $this->postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetPurpose'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetPurposeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetPurposeRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetPurpose'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetPurpose'
            );
        }

        $resourcePath = '/api/v1/channels.setPurpose';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetReadOnly
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetReadOnlyBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20021
     */
    public function postApiV1ChannelsSetReadOnly($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetReadOnlyWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyWithHttpInfo
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetReadOnlyBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetReadOnlyWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20021';
        $request = $this->postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyAsync
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetReadOnlyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetReadOnlyAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo
     *
     * Set Channel ReadOnly
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetReadOnlyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetReadOnlyAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20021';
        $request = $this->postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetReadOnly'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetReadOnlyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetReadOnlyRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetReadOnly'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetReadOnly'
            );
        }

        $resourcePath = '/api/v1/channels.setReadOnly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetTopic
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTopicBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20022
     */
    public function postApiV1ChannelsSetTopic($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetTopicWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetTopicWithHttpInfo
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTopicBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20022, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetTopicWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20022';
        $request = $this->postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20022',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetTopicAsync
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTopicBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTopicAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetTopicAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetTopicAsyncWithHttpInfo
     *
     * Set Channel Topic
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTopicBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTopicAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20022';
        $request = $this->postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetTopic'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTopicBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetTopicRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetTopic'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetTopic'
            );
        }

        $resourcePath = '/api/v1/channels.setTopic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsSetType
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTypeBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20021
     */
    public function postApiV1ChannelsSetType($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsSetTypeWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsSetTypeWithHttpInfo
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTypeBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsSetTypeWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20021';
        $request = $this->postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsSetTypeAsync
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTypeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTypeAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsSetTypeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsSetTypeAsyncWithHttpInfo
     *
     * Set Channel Type
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTypeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsSetTypeAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20021';
        $request = $this->postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsSetType'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsSetTypeBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsSetTypeRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsSetType'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsSetType'
            );
        }

        $resourcePath = '/api/v1/channels.setType';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApiV1ChannelsUnarchive
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsUnarchiveBody $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function postApiV1ChannelsUnarchive($x_auth_token, $x_user_id, $body = null)
    {
        list($response) = $this->postApiV1ChannelsUnarchiveWithHttpInfo($x_auth_token, $x_user_id, $body);
        return $response;
    }

    /**
     * Operation postApiV1ChannelsUnarchiveWithHttpInfo
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsUnarchiveBody $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApiV1ChannelsUnarchiveWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse401',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postApiV1ChannelsUnarchiveAsync
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsUnarchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsUnarchiveAsync($x_auth_token, $x_user_id, $body = null)
    {
        return $this->postApiV1ChannelsUnarchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApiV1ChannelsUnarchiveAsyncWithHttpInfo
     *
     * Unarchive a Channel
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsUnarchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApiV1ChannelsUnarchiveAsyncWithHttpInfo($x_auth_token, $x_user_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApiV1ChannelsUnarchive'
     *
     * @param  string $x_auth_token The &#x60;authToken&#x60; of the authenticated user. (required)
     * @param  string $x_user_id The &#x60;userId&#x60; of the authenticated user. (required)
     * @param  \Swagger\Client\Model\V1ChannelsUnarchiveBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApiV1ChannelsUnarchiveRequest($x_auth_token, $x_user_id, $body = null)
    {
        // verify the required parameter 'x_auth_token' is set
        if ($x_auth_token === null || (is_array($x_auth_token) && count($x_auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_auth_token when calling postApiV1ChannelsUnarchive'
            );
        }
        // verify the required parameter 'x_user_id' is set
        if ($x_user_id === null || (is_array($x_user_id) && count($x_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_user_id when calling postApiV1ChannelsUnarchive'
            );
        }

        $resourcePath = '/api/v1/channels.unarchive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_auth_token !== null) {
            $headerParams['X-Auth-Token'] = ObjectSerializer::toHeaderValue($x_auth_token);
        }
        // header params
        if ($x_user_id !== null) {
            $headerParams['X-User-Id'] = ObjectSerializer::toHeaderValue($x_user_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
